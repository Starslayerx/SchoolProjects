参数的默认值:

- 所有带默认值的参数必须放在最右边
- 如果一个函数有原型声明，且原型声明在定义前，则默认参数值应该在函数原型中给出
- 如果只有函数的定义，或函数定义在前，则默认参数可以在函数定义中给出

## inline 内联函数
调用函数时，程序需要给函数分配栈内存，不必要的调用会浪费内存。如果要实现一个很简单的功能，但又要将其封装到函数中时，就需要内敛函数。inline只是对编译器的一个建议，编译器不一定就会内联展开函数，并且有些函数编译器可能自动展开为内联函数

- 内联函数内不能有循环语句和switch语句
- 内联函数定义必须在内联函数第一次被调用前
- 对内联函数不能进行异常接口声明

以下是google的C++编码规范，可以参考
> 内联函数：
Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.
定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.

>优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.

>缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。

>结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!
另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).

>有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.

总之，要实现一个很简单的功能，例如比大小时就可以使用内联函数，其他稍微复杂一点打函数都不要使用内联

## constexpr函数
constexpr函数承诺其所有参数都是常量(const expression)时其返回值也全部是常量，这样在编译期间就可以直接算出结果，

- constexpr函数只允许出现一次return语句

## friend 友元
友元函数并不属于该类, 但是可以访问类中的任意数据, 就像朋友一样, 可以在函数前面加上`friend`关键字实现,
```cpp
friend 返回类型 function() {}		// 全局友元函数
friend 返回类型 类名::function() {}		//作用于某个类的友元函数
```
对一第一种只要在类中声明该函数是友元函数即可


友元类中的所有函数成员都可以访问另一个类中的所有成员
```cpp
friend class 类名{}
```
*注意事项*

- 友元关系不能继承
- 友元关系不具有交换性, A是B的友元,B不是A的友元
- 友元关系非传递,B是A的友元,C是B的友元,但C不是A的友元
- 友元的声明是不受 public、protected、private 关键字限制的

## 函数的重载
即同一个名字的函数，有不同形式或数量的型参，用来实现类似的功能

- 返回值不能用来区分重载函数
- 不要将功能不同的函数重载

